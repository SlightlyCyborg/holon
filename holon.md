# Holon

## *Ch 0: Introduction*

Holon is defined by Wikipedia as a [system](https://en.wikipedia.org/wiki/System) (or [phenomenon](https://en.wikipedia.org/wiki/Phenomenon)) that is an [evolving](https://en.wikipedia.org/wiki/Evolution) [self-organizing](https://en.wikipedia.org/wiki/Autopoesis) [dissipative](https://en.wikipedia.org/wiki/Dissipative_structure)\[[*citation needed*](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed)\] [structure](https://en.wikipedia.org/wiki/Structure), composed of other holons, whose structures exist at a balance point between [chaos](https://en.wiktionary.org/wiki/chaos) and order. A holon isn't actually "real" in the sense that matter is real. A holon is an abstraction. In programming terms, a Holon is the interface and not the implementation. Machine code is the only form of information that runs on real processors and likewise, matter as bounded packets of energy is the only thing that runs around in the universe and every conceptualization above the quanta is macroscopic "high level code" that predicts how the low level stuff will behave. When the college hippies say "Everything is one man. We are all just endless energy", there is some truth to that. However, when discussing with hippies, it is best to stay away from the concrete details of reality, lest you decide to throw a physics book at them out of anger and of an attempt to break them from their trance like oneness. What the hippies do get that more straitlaced peers overlook is that reality arrives at our perceptions in "packets of understandability". I don't converse with neurons, I converse with humans. China doesn't deal with US citizens in general, but it sure deals with the United States. Each fractal level of reality can be defined by an interface and even though the implementation of that interface consists of layers and layers and layers of abstraction on top of atoms, reality has found it "best" to encapsulate these layers in the same way a programmer encapsulates their data into an object. These objects of reality are what I call "Holons"

The intent of this book is to define the various Holons found in our reality. As I describe the various holons and their interactions in this book, I will link to classes of my Holon codebase written in Java that formally defines the concepts involved. The end result is a coded implementation of my own mental model alongside my description of that model which will be found in this book. I do not intend to make this book too code intensive, but I will insert small snippets of formatted code into the text of this book as I see fit. The goal of the book itself is to describe my formal mental model of reality to any technically minded reader, regardless of their programming experience.  For the more experienced programmers reading this book, I hope you find my codebase to be useful. The code is heavily tailored to my own mental model and may not be suited to your needs, but over the course of this book I think both experienced and non-experienced reader alike will find just how important it is to formally define even the most mundane of concepts in computer code. There were many bugs lurking in my intuitive/unformal understanding of reality that revealed themselves to be patched once they were formally defined in code. If you, the reader, push through this book despite its density, verbosity, and eccentric: in the end I think you will see the power that codifying your mental model brings into your life. Software is truly eating the world.

## *Digital Reasoning*

Biases are generally easy to percieve in others but difficult to percieve in oneself. Biases can stack on top of eachother to form idologies that are then transfered memetically to various minds. The minds that are most habitable to various ideologies probably had several of the underlying biases contained in the ideology, but probably in less evolved forms. I could fill this section with example of these ideologies, but it will only serve to anger readers. Just think your most hated ideological group of people and then imagine what kind of mental biases they must have in order to believe the things that they do. Really try to put yourself into the mindset of a person in this vile group, whatever that group is? What life experiences must these people have had. What life experiences haven't they had. If you were in their shoes, but retained an angel of your rational self on your shoulder attempting to convince you that this vile ideology is wrong, what would that angel say?

The truth is that you yourself may have underlying biases which allow various ideological memes to reside in your mind. There may be people out there who will attempt to vilify you because of these ideas. When people decide to vilify others, they fail to empathize with the truths that can be found in another person's mindset regardless of how large or small those truths may be.

One of the goals of this project is to build "digital reasoning machines" to structure one's mental model of the world such that the biases that seem to cloud the rationality of much of the world around us does not affect your judgement more than it has to. Completely eliminating bias is impossible (everyone and everything has a perspective). However, what machines lack in intuition they gain in objectivity. A computer only does what it is programmed to do. The rigidity of the machine may help to root out biases and untruths from ones mental model.

Let me give an example in my daily life: presume that I make a resolution to spend enough time reading each day. If I am particularly uncommitted to this idea, I won't even specify how much "enough time is". If I am at least a bit serious about this goal, I will define it quantitatively by stating "I will read 40 minutes each day from a software development book". Now I have formal fitness function that I as a human can understand, but I won't know exactly how to evaluate my performance. I may get a 10 minute phone call in the middle of my reading session and forget to keep track of the time so I just count it towards my reading for that day. Even worse still is that in order to stay committed to my resolution, I have to track how good I am doing so I can plan about how to stay commited when inevitable interferences come up. Say my work hours change and that time block from 6am to 7am I normally spend reading now needs to be spent driving so I can get to the office by 7. It may be too easy to just forget about doing the reading. If I have a digital tracker in place to alert me, this won't be a problem.

## *The tech stack*

A major focus of software engineering has been on tool development. For this reason, a component of Holon is the tech stack. Software developers have editors, command lines, IDEs, debuggers, scripts, project management tools, source control, and much more. Each class of tech has many different species to choose from. I personally wanted to have written most of the tech stack that I directly interact with.

The tech stack gets its own class and holds a list of many system components at various levels in the stack. Software, hardware, daemons, and documentation are all listed in the stack.

### The shell

The number of configurations a shell program can run are vastly greater than what an equivalent GUI program can run. The power of the shell simply can't be overlooked. However, most Unix distributions come with Bash as their shell and few people decide to replace it. Shell is equivalent to Bash, but that doesn't have to be the case. I built my own shell in Java. It allows me to launch sandboxed Java programs in the same JVM that the shell is running in. This means that Java threads become much like Linux processes in that the Java thread is how program seperation occurs. Memory between both programs are obviously shared, but this is not a problem due to high level memory management. In a c++ program, it would be easy for one thread to clobber the memory of another thread, but in Java the only way that can happen is if one thread has reference to an object that another thread is using. If I sufficiently seperate the programs that are running in my JVM using a custom class loader, it will become virtually impossible for one program to clobber the other program. The reason for this is that any object created with my custom class loader can not be used by an object created by a seperate instance of my custom class loader. If an object's defining classloader is not in the Classloader hierarchy of another object, then the 2 objects can never interact with eachother. Usually classloaders form a single linked list, which ensures that all objects have their defining class loader in the heirarchy of all other objects. However, my custom classloader branches that linked list into a tree which means that some objects are completely seperated from other objects in the classloader hierarchy. The only way these 2 objects can communicate with eachother is by passing around objects whose classes were defined in classloaders that are higher than the branch point seperating the 2 objects in the classloader heirarchy. Things in the Java language spec such as String, Object, Integer, etc can all be shared amongst these seperate processes, but the process that instanciated the custom class loaders would have to be responsible for using reflection to pass common objects around. One object can not simply hold reference to another object defined in seperate branches of the classloader heirarchy.

What I can do is create a pseudo-pipe structure that routes objects that are defined by a common classloader between to objects sperated by their branching class loaders. I could define a Pipe object in a common class loader, instanciate it, and then pass it to the various objects defined by the branching class loaders. Then the 2 objects could communicate via predefined pipe API. Any object defined by a common Classloader could be passed through the pipe if neccisary. In linux, usually the only things passes through pipes are primatives, because primatives are the least common denominator of processes whos internal structure is written in C code. However, in my scheme, any object that has been defined by a common classloader in Java is fair game. Even complex user made structures can be piped directly as long as the class of the object being piped shares the same classloader relative to the objects doing the piping.


### The editor

The editor I built is a hybrid of Emacs and Vim. I want an editor that is extensible in a language I like writing in and neither Vim or Emacs meets that requirement. That alone would be enough reason for me to want to write myown editor, but there are still more reasons to do so. By writing the editor, I will understand how its interneals work which will greatly enhace my ability to write extensions for it.

#### Components

The main class inside the editor is the Buffer. The Buffer class is what logically manages the text that is being written. It is the only object that gets fed to the Editor window's display method. The buffer has a name and is associate witha particular file that it can read from and write to.

### Perception

Cybernetics systems almost always have inputs that drive the feedback loops. Holon has several main inputs: Internal system state, Keyboard input, Internet API calls, Vision.

#### Internal System State

Holon will constantly be monitoring itself. It will look at how many processes are running, what code is being executed, and what results are being produced. Much of this data will be recorded in log files that Holon will then analyze. Holon will have a fitness function related to its internal system state and it will use the log files + the fitness function to back propogate error into the system and learn what motifications should be made to make the system more fit. Likewise, it will produce human readable reports so I can manually tweak code to perform better relative to the fitness function.

#### Keyboard input

Keyboard input is the primary way that I currently communicate with digital cybernetics systems. The output of my 10 fingers has less social side effects than talking to my system. It also allows me to input througha large domain very precise information that speaking just can not do efficiently. Imagine trying to write code using your voice. "Open paren" for instance has 3 syllables that must be pronounced, where as I can simply hold shift and press the ( key to generate that symbol on my keyboard. Holon will need to know how to interpret keys in every situation. Emacs handles this requirement by allowing users to define "modes", both major and minor. A mode defines how a program will respond to a key and a mode exists independently from a particular program running that mode.

#### Vision

This mode of perception is the one that humans are most familiar with and the one tha computers have the most trouble with. Only in the last decade have computer scientists began to tackle vision in a significant way. ImageNet competitions have been the driving force behind the advancements in computer vision technology. Now with a simple GPU it easy to implement object recognition on a home computer. Holon will have a lot of computer vision incorporated into the system, initially just to observe me as the user. Over time, I will instanciate components of Holon into robots IRL that will then collect data about their environments. I envision a robotic pet that follows me around, constantly collecting data about my life experience

## Daemons

Each daemon process runs in a Java thread on a single JVM instance. The most computationally intensive daemon process is the vision process. It is constantly recording and analyzing visual data in Holon's environment. The environment is defined by the PhysicalSpace in which all hardware controlled by Holon is located in. For instance, if I have a server at home running Holon and an instance inside my smart glasses that is feeding visual data to the server at home via a 4G connection, then the Holon environment consistes of the space around my person and the space the server occupies (which the server may be sensing via security cameras and the like).

## Holon environment

A holon environment is defined by all the Holon instances that a single user has direct control over. Any machine in the Holon environment can interact with any other machine via the public methods in the Holon classes. Because of liberal security policy, it is important that Holon detects comprimises early and often in order to boot comprimised instances from the Holon environment.

## Code Editing Tools

Holon is built for hackers. Its goal is to enable human evolution through technology. As such, one of its major components is a code manipulation suite. Among other things, Holon aspires to be as powerful for computer programmers as an IDE like Eclipse or Visual Studio. Unlike these IDEs, Holon will include many other tools of information processing. The knowlege required for optimal programming does not exist in from knowledge in other seemingly inconsequential subjects. All subjects inform eachother. As such, classes for every physical and abstract model I can think of will be at my fingertips when programming.

## Sources of inspiration

In this section, I want to identify several of the sources of inspiration I have had for the Holon project. This project did not originate as a startup idea or as a mandate from a book. Rather it began its life as a destraction. In 2014, I started working on building a robotics company, but I constanly was distracted with the meta process of improving my performance in building and designing robots. By 2016, I started working full time on a self improvement AI with the justification that I would put it inside of a robot when I was finished. I desperately tried to commenserate what my stated goals where with what I was actually working on. Slowly, I began to realize that personifying the system I was building was a detriment to using the system. It took ~4 years to finally realize that what I cared most about was a cybernetic mind extension. It took me 4 years to figure out what I was really even working on. It took an extra year and a half to feel confident in pursuing this line of work in earnest. It has seemingly no way to monitize it, because in effect, I am suggesting that everyone build their own version of Holon using my version as just 1 implementation of the idea. Despite this, I have been given an indication that my pursuit is worthwhile by the book Principles by Ray Dalio. In the book he discusses how humans will systemize their thought processes in expert systems that can be compiled and executed on digital CPUs. In the book, Mr Dalio said that this evolution of human thought is of the upmost importance. I agree with him. My goal is not to build a thinking machine, but rather to build a system that is tightly coupled to myself. I see this as a massive self improvement project. How can one make money from that when "self-help" seems to be the industry of hucksters?

### If Holon works like I expect it to, then it won't become my primary income source.

If Holon is truely successful at improving my cognitive performance, then I shouldn't have to make the majority of my money on it. With improved cognitive performance, I will be able to make my money elsewhere. It is only then that I will truly stress-test Holon. The reason I am willing to read Ray Dalio's self-help book and not the "Here in My Garage" guy's book, is that Ray has already stress tested his ideas. He is not making the majority of his money on selling his book. Rather, he earned his money from making intelligent principled decisions in hedge fund investments. If my hypothesis about Holon is correct, it will lead to many projects and companies that will make money for me. It isn't that I don't plan to monitize Holon, but it is more that I don't want Holon to make up a large percentage of my income
