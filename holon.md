# Holon

## *Ch 0: Introduction*

Holon is defined by Wikipedia as a [system](https://en.wikipedia.org/wiki/System) (or [phenomenon](https://en.wikipedia.org/wiki/Phenomenon)) that is an [evolving](https://en.wikipedia.org/wiki/Evolution) [self-organizing](https://en.wikipedia.org/wiki/Autopoesis) [dissipative](https://en.wikipedia.org/wiki/Dissipative_structure)\[[*citation needed*](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed)\] [structure](https://en.wikipedia.org/wiki/Structure), composed of other holons, whose structures exist at a balance point between [chaos](https://en.wiktionary.org/wiki/chaos) and order. A holon isn't actually "real" in the sense that matter is real. A holon is an abstraction. In programming terms, a Holon is the interface and not the implementation. Machine code is the only form of information that runs on real processors and likewise, matter as bounded packets of energy is the only thing that runs around in the universe and every conceptualization above the quanta is macroscopic "high level code" that predicts how the low level stuff will behave. When the college hippies say "Everything is one man. We are all just endless energy", there is some truth to that. However, when discussing with hippies, it is best to stay away from the concrete details of reality, lest you decide to throw a physics book at them out of anger and of an attempt to break them from their trance like oneness. What the hippies do get that more straitlaced peers overlook is that reality arrives at our perceptions in "packets of understandability". I don't converse with neurons, I converse with humans. China doesn't deal with US citizens in general, but it sure deals with the United States. Each fractal level of reality can be defined by an interface and even though the implementation of that interface consists of layers and layers and layers of abstraction on top of atoms, reality has found it "best" to encapsulate these layers in the same way a programmer encapsulates their data into an object. These objects of reality are what I call "Holons"

The intent of this book is to define the various Holons found in our reality. As I describe the various holons and their interactions in this book, I will link to classes of my Holon codebase written in Java that formally defines the concepts involved. The end result is a coded implementation of my own mental model alongside my description of that model which will be found in this book. I do not intend to make this book too code intensive, but I will insert small snippets of formatted code into the text of this book as I see fit. The goal of the book itself is to describe my formal mental model of reality to any technically minded reader, regardless of their programming experience.  For the more experienced programmers reading this book, I hope you find my codebase to be useful. The code is heavily tailored to my own mental model and may not be suited to your needs, but over the course of this book I think both experienced and non-experienced reader alike will find just how important it is to formally define even the most mundane of concepts in computer code. There were many bugs lurking in my intuitive/unformal understanding of reality that revealed themselves to be patched once they were formally defined in code. If you, the reader, push through this book despite its density, verbosity, and eccentric: in the end I think you will see the power that codifying your mental model brings into your life. Software is truly eating the world.

## *Digital Reasoning*

Biases are generally easy to percieve in others but difficult to percieve in oneself. Biases can stack on top of eachother to form idologies that are then transfered memetically to various minds. The minds that are most habitable to various ideologies probably had several of the underlying biases contained in the ideology, but probably in less evolved forms. I could fill this section with example of these ideologies, but it will only serve to anger readers. Just think your most hated ideological group of people and then imagine what kind of mental biases they must have in order to believe the things that they do. Really try to put yourself into the mindset of a person in this vile group, whatever that group is? What life experiences must these people have had. What life experiences haven't they had. If you were in their shoes, but retained an angel of your rational self on your shoulder attempting to convince you that this vile ideology is wrong, what would that angel say?

The truth is that you yourself may have underlying biases which allow various ideological memes to reside in your mind. There may be people out there who will attempt to vilify you because of these ideas. When people decide to vilify others, they fail to empathize with the truths that can be found in another person's mindset regardless of how large or small those truths may be.

One of the goals of this project is to build "digital reasoning machines" to structure one's mental model of the world such that the biases that seem to cloud the rationality of much of the world around us does not affect your judgement more than it has to. Completely eliminating bias is impossible (everyone and everything has a perspective). However, what machines lack in intuition they gain in objectivity. A computer only does what it is programmed to do. The rigidity of the machine may help to root out biases and untruths from ones mental model.

Let me give an example in my daily life: presume that I make a resolution to spend enough time reading each day. If I am particularly uncommitted to this idea, I won't even specify how much "enough time is". If I am at least a bit serious about this goal, I will define it quantitatively by stating "I will read 40 minutes each day from a software development book". Now I have formal fitness function that I as a human can understand, but I won't know exactly how to evaluate my performance. I may get a 10 minute phone call in the middle of my reading session and forget to keep track of the time so I just count it towards my reading for that day. Even worse still is that in order to stay committed to my resolution, I have to track how good I am doing so I can plan about how to stay commited when inevitable interferences come up. Say my work hours change and that time block from 6am to 7am I normally spend reading now needs to be spent driving so I can get to the office by 7. It may be too easy to just forget about doing the reading. If I have a digital tracker in place to alert me, this won't be a problem.

## *The tech stack*

A major focus of software engineering has been on tool development. For this reason, a component of Holon is the tech stack. Software developers have editors, command lines, IDEs, debuggers, scripts, project management tools, source control, and much more. Each class of tech has many different species to choose from. I personally wanted to have written most of the tech stack that I directly interact with.

The tech stack gets its own class and holds a list of many system components at various levels in the stack. Software, hardware, daemons, and documentation are all listed in the stack.

### The shell

The number of configurations a shell program can run are vastly greater than what an equivalent GUI program can run. The power of the shell simply can't be overlooked. However, most Unix distributions come with Bash as their shell and few people decide to replace it. Shell is equivalent to Bash, but that doesn't have to be the case. I built my own shell in Java. It allows me to launch sandboxed Java programs in the same JVM that the shell is running in. This means that Java threads become much like Linux processes in that the Java thread is how program seperation occurs. Memory between both programs are obviously shared, but this is not a problem due to high level memory management. In a c++ program, it would be easy for one thread to clobber the memory of another thread, but in Java the only way that can happen is if one thread has reference to an object that another thread is using. If I sufficiently seperate the programs that are running in my JVM using a custom class loader, it will become virtually impossible for one program to clobber the other program. The reason for this is that any object created with my custom class loader can not be used by an object created by a seperate instance of my custom class loader. If an object's defining classloader is not in the Classloader hierarchy of another object, then the 2 objects can never interact with eachother. Usually classloaders form a single linked list, which ensures that all objects have their defining class loader in the heirarchy of all other objects. However, my custom classloader branches that linked list into a tree which means that some objects are completely seperated from other objects in the classloader hierarchy. The only way these 2 objects can communicate with eachother is by passing around objects whose classes were defined in classloaders that are higher than the branch point seperating the 2 objects in the classloader heirarchy. Things in the Java language spec such as String, Object, Integer, etc can all be shared amongst these seperate processes, but the process that instanciated the custom class loaders would have to be responsible for using reflection to pass common objects around. One object can not simply hold reference to another object defined in seperate branches of the classloader heirarchy.

What I can do is create a pseudo-pipe structure that routes objects that are defined by a common classloader between to objects sperated by their branching class loaders. I could define a Pipe object in a common class loader, instanciate it, and then pass it to the various objects defined by the branching class loaders. Then the 2 objects could communicate via predefined pipe API. Any object defined by a common Classloader could be passed through the pipe if neccisary. In linux, usually the only things passes through pipes are primatives, because primatives are the least common denominator of processes whos internal structure is written in C code. However, in my scheme, any object that has been defined by a common classloader in Java is fair game. Even complex user made structures can be piped directly as long as the class of the object being piped shares the same classloader relative to the objects doing the piping.


### The editor

The editor I built is a hybrid of Emacs and Vim. I want an editor that is extensible in a language I like writing in and neither Vim or Emacs meets that requirement. That alone would be enough reason for me to want to write myown editor, but there are still more reasons to do so. By writing the editor, I will understand how its interneals work which will greatly enhace my ability to write extensions for it.

#### Components

The main class inside the editor is the Buffer. The Buffer class is what logically manages the text that is being written. It is the only object that gets fed to the Editor window's display method. The buffer has a name and is associate witha particular file that it can read from and write to.

### Perception

Cybernetics systems almost always have inputs that drive the feedback loops. Holon has several main inputs: Internal system state, Keyboard input, Internet API calls, Vision.

#### Internal System State

Holon will constantly be monitoring itself. It will look at how many processes are running, what code is being executed, and what results are being produced. Much of this data will be recorded in log files that Holon will then analyze. Holon will have a fitness function related to its internal system state and it will use the log files + the fitness function to back propogate error into the system and learn what motifications should be made to make the system more fit. Likewise, it will produce human readable reports so I can manually tweak code to perform better relative to the fitness function.

#### Keyboard input

Keyboard input is the primary way that I currently communicate with digital cybernetics systems. The output of my 10 fingers has less social side effects than talking to my system. It also allows me to input througha large domain very precise information that speaking just can not do efficiently. Imagine trying to write code using your voice. "Open paren" for instance has 3 syllables that must be pronounced, where as I can simply hold shift and press the ( key to generate that symbol on my keyboard. Holon will need to know how to interpret keys in every situation. Emacs handles this requirement by allowing users to define "modes", both major and minor. A mode defines how a program will respond to a key and a mode exists independently from a particular program running that mode.

#### Vision

This mode of perception is the one that humans are most familiar with and the one tha computers have the most trouble with. Only in the last decade have computer scientists began to tackle vision in a significant way. ImageNet competitions have been the driving force behind the advancements in computer vision technology. Now with a simple GPU it easy to implement object recognition on a home computer. Holon will have a lot of computer vision incorporated into the system, initially just to observe me as the user. Over time, I will instanciate components of Holon into robots IRL that will then collect data about their environments. I envision a robotic pet that follows me around, constantly collecting data about my life experience
